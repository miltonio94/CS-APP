#+title: Chapter 1: A tour of computer systems

* Table of content :toc:
- [[#11-information-is-bits--context][1.1 Information is bits + Context]]
- [[#12-programs-are-translated-by-other-programs-into-different-forms][1.2 Programs are translated by other programs into different forms]]
- [[#13-it-pays-to-understand-how-compilation-systems-work][1.3 It pays to understand how compilation systems work]]
- [[#14-processors-read-and-interpret-instructions-stored-in-memory][1.4 Processors read and interpret instructions stored in memory]]
  - [[#141-hardware-organisation-of-a-system][1.4.1 Hardware organisation of a system]]
  - [[#142-running-the-hello-world-program][1.4.2 Running the hello world program]]
- [[#15-caches-matter][1.5 Caches matter]]

* 1.1 Information is bits + Context
The hello world program from K&R book will be the starting point.
#+begin_src c
#include <<stdio.h>

int main(){
  printf("hello world\n");
  return 0;
}
#+end_src
Our program starts as a source file (or source program) that is created by the programmer with an editor and saved with the ~.c~ extension. The code is a sequence of bits, each represented by either a 1 or a 0, organised in 8-bit chunks called bytes. Each one of these bytes represents a character in the program.

Most computers represent text character using the ASCII standards that represents each character as a unique byte-size integer. For example, here's our hello world program represented by ASCII.

#+CAPTION:The ASCI text representation of hello world
#+NAME: Figure 1.2
[[./imgs/figure1.2.png]]

The hello world program is stored in a file as a sequence of bytes. Each byte represents a integer value that corresponds to a character. As an example the first character is stored as the value 35 which corresponds to the character ~#~. The second value is 105 which corresponds to the character ~i~ and so on. One thing of note is that each line is terminated by the invisible character ~\n~ which is represented by the integer value 10. Files such as the one that stores our hello world program and that consist of ASCII characters are known as text files. All other files are known as binary files.

The representation of our hello world program above illustrates a fundamental idea: All information in a system, this includes files, programs, data stored in memory, and data transferred across a network, are all represented as bits. The only thing that differentiates them is the context that they are viewed in. In one context the same sequence of bytes might represent a character string, in another an integer, or a floating point number or even a machine instruction.

Programmers need to understand machine representation of numbers because they are not the same as integers and real numbers. The are finite approximations that can behave in unexpected ways.
* 1.2 Programs are translated by other programs into different forms
The hello world program begins it's life as a high level C program, this is because it's human readable code. For the program to be able to run on a system, each individual statement must be translated into /machine-language/ instructions. These instructions then need to be packaged into a /executable object program/ and then stored as a binary. These object programs can also be referred to as an /executable object/.

The translation form source code to object file in UNIX systems are done by something called a /compiler driver/.
~linux> gcc -o helloWorld main.c~
In the above the gcc compiler will read our source file ~main.c~ and translate it to an executable object called ~helloWorld~. This translation can be represented by the figure bellow
#+CAPTION: The compilation system
#+NAME: FIgure 1.3
[[./imgs/figure1.3.png]]
The whole process is done by four separate programs: the /preprocessor/, /compiler/, /assembler/ and /linker/, in that order. This collective process is called the compilation system.
*** /Preprocessing phase/
  The preprocessor (cpp) will make changes to the original program according to commands that begin with ~#~. For example the ~#include <stdio.h>~ command will instruct the preprocessor to read the contents of the system header file ~stdio.h~ and insert it into the program text, resulting in a new program that typically has the ~.i suffix.
*** /Compilation phase/

  The compiler (cc1) will translate ~helloWorld.i~ into ~helloWorld.s~. ~helloWorld.s~ will contain an assembly language program. This file wil contain a definition of main in assembly that could look like the below (depending on the machine and its architecture):
#+begin_src asm
    main:
        subq $8, %rsp
        movl $.LCO, %edi
        call puts
        movl $0, %eax
        addq $8, %rsp
        ret
#+end_src

Each of the lines above correspond to low-level machine language instructions. Assembly language is useful as it serves as a targget for many comiled languages as a common output. For example, C and Fortrans compilers both generate files in the same assembly language.
*** /Linking phase/
Our file makes use of code that is not present in our source program, for example the ~printf~ function resides in a seperate precompiled object called ~printf.o~. This code must somehow be merged into our ~helloWorld.o~ program, The linker (ld) is responsible for this merging step. The result then is our ~helloWorld~ file that is an executable that is ready to be loaded into memory and executed by the system.
* 1.3 It pays to understand how compilation systems work
Some important reasons for understanding the compilation system are:
- /Optimising program/. Knowing how some statements are faster then others and why. Knowing how structuring the code can impact the efficiency of the program.
- /Understanding Link-time errors/. Why do they happen and how can they be fixed. Why does it happen only during runtime sometimes.
- /Avoiding security holes/. Understanding why buffer overflow works and how it can lead to security flaws.
* 1.4 Processors read and interpret instructions stored in memory
Now the hello our ~main.c~ source code has been translated by the compilation system into an executable object. To run it in an unix system we type the following in the shell (a program in of it self)
#+begin_src
>>> ./helloWorld
hello world
>>>
#+end_src
** 1.4.1 Hardware organisation of a system
The following illustration will help understand the typical organisation of a system
#+CAPTION: Hardware organisation of a typical system
#+NAME: FIgure 1.4
[[./imgs/figure1.4.png]]
*** Buses
Buses are a collection of electrical conduits that carry bytes of information back and forth between components. Buses are designed to transfer fixed-sized chunks of bytes called /words/. The /word size/ (the number of bytes a word contains) is system dependent and known as a system parameter. Most machines now have a word size of either 4 bytes (on 32 bit machines) or 8 bytes (on 64 bit machines).
*** I/O Devices
Input/output (I/O) devices are the systems connections to the external world. In the example above it's the mouse, keyboard, display and disk.
The I/O devices are connected to the I/O bus by either a /controller/ or an /adaptor/. The main difference between a controller and an adaptor is how it's packaged. A controller is a chip in either the device itself or on the systems main printed circuit board (usually called a motherboard). An adaptor is a card that is plugged into a slot on the motherboard.
*** Main memory
The main memory is a temporary storage device that holds programs and the data that they manipulate. Main memory consists of a collection /dynamic random access memory/ (DRAM) chips. Memory is organised as a linear array of bytes. Each byte has it's own unique address (an array index) starting from zero. Generally, each machine instructions that makes a program may have any number of bytes. The sizes of data of a C program vary depending on their type. For example on a typical x86-64 machine running linux the types int and float are four bytes long.
*** Processor
The /central processing unit/ (CPU), also known as the processor is what interprets (/executes/) instructions stored in memory. It contains a word sized storage device at it's core known as the /program counter/ (PC.) The program counter will point to (contains the address of) some machine instruction in main memory.

From the point that the system is powered on to the point it is powered off the programmer processor will execute instructions that are pointed at by the program counter and will update the program counter to point to the next instruction. A processors instruction execution model is defined by it's /instruction set architecture/. The sequence described by the model is the following:
Read instruction from memory that is pointed at by the program counter -> Interpret the bits in the instruction -> Perform simple operation represented by instruction -> Update the program counter to point to next instruction
These instructions in memory may or may not be contiguous.

The number of operations are limited and revolve around main memory, the /register file/, and the /arithmetic/logic unit/ (ALU). Th register file is a small storage device made up of a collection of word sized register, each of these registers have a unique name. The arithmetic/logic unit computes new data and address values. Some examples of these simple operations are:
- Load: Copy a byte or word from memory into a register and overwrite it's previous contents
- Store: Copy a byte or word from a register and store it in memory overwriting it's previous content
- Operate: Copy the contents of two registers to the arithmetic/logic unit, perform arithmetic operation on them and store the result in a register overwriting it's previous content.
- Jump: Extract a word from the instruction and copy into the program counter overwriting the program counter's previous content.

In reality the process in much more complicated than this. Modern processors use complicated mechanisms to speed up the execution. A distinction has to be made between a processor's instruction set architecture and it's /microarchitecture/. The processor instruction set architecture describes the effect of each machine code instruction, the microarchitecture describes how the processor is actually made.
** 1.4.2 Running the hello world program
Now we understand that when a user types into the shell the command to run the program the shell loads the executable files via a series of instructions that copies the program's code and data from disk to main memory. The data of the program includes  the string of characters ~hello world\n~ that will be printed out.

/Direct memory access/ is a technique that allows for the system to pass data from disk to memory  without having to pass through the processor.

When the code and data are present in memory the processor will begin to execute the machine instruction of the program' ~main~ routine. The instructions will copy the bytes in the ~hello world\n~ string from memory to the register file and then from there to the display device where the user will then be able to see it.
Here's a figure outlining this process
[[./imgs/figure1.5.png]]
* 1.5 Caches matter
